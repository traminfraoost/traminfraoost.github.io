<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Map OpenLayers</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"> <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.2/awesomplete.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/awesomplete/1.1.2/awesomplete.min.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.4/xlsx.full.min.js"></script> <!-- Include SheetJS library -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            left: 300px;
            bottom: 30px;
            width: calc(100% - 300px);
        }


        #logoAndEditorContainer {
            display: flex; /* Use flexbox to align items horizontally */
            align-items: center; /* Center items vertically */
            margin-bottom: 10px; /* Add margin at the bottom */
        }

        #logoContainer,
        #editorLoginContainer {
            margin-right: 10px; /* Add margin between the logo and login button */
        }


        #editorLoginButton {
            padding: 5px; /* Adjust padding */
            font-size: 12px; /* Adjust font size */
            height: 40px; /* Set the height to match the logo */
            width: 100px;
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
            margin-left: 50px;
        }

        #controls {
            position: absolute;
            top: 0;
            left: 0;
            height: calc(100% - 40px);
            width: 300px;
            background-color: #f8f9fa; /* Light gray background */
            padding: 10px;
            box-sizing: border-box;
            text-align: left; /* Align text to the left */
        }

        .pointer {
            position: absolute;
            top: -22px;
            left: -9px;
            font-size: 24px;
            color: blue;
            z-index: 1000;
         }

        .legend {
            position: absolute;
            bottom: 40px;
            left: 310px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .popup {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 10px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            bottom: 35px;
            right: 10px;
            width: 200px;
            height: 300px;
            overflow: scroll;
            max-height: 300px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .control-box {
            margin-bottom: 10px;
        }

        .control-box label {
            display: block; /* Each label on a new line */
            margin-bottom: 5px; /* Add space between labels */
            font-weight: bold; /* Make label text bold */
        }

        .control-box input[type="text"],
        .control-box input[type="range"],
        .control-box button {
            width: 100%; /* Take up full width */
            padding: 5px; /* Add padding */
            box-sizing: border-box; /* Include padding in width */
        }

        .control-box button {
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
        }

        .control-box button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

        .export-button {
            padding: 5px; /* Adjust padding */
            font-size: 12px; /* Adjust font size */
            height: 40px; /* Set the height to match the other buttons */
            width: 100px; /* Set the width */
            background-color: #007bff; /* Blue button color */
            color: white; /* White text color */
            border: none; /* Remove border */
            cursor: pointer; /* Add pointer cursor */
            margin-left: 0px; /* Adjust margin */
            border-radius: 5px; /* Add border radius */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add shadow */
        }

        .export-button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

        #controls {
            position: fixed; /* or absolute */
            top: 0;
            left: 0;
            height: 100%; /* Adjust as needed */
            width: 300px; /* Adjust as needed */
            background-color: #f8f9fa;
            overflow-y: auto; /* Enable vertical scrolling */
            padding: 10px;
            box-sizing: border-box;
            z-index: 1000; /* Ensure it's above other content */
        }

    </style>
</head>
<body>
<div id="controls">
    <div class="control-box" id="logoAndEditorContainer">
        <div id="logoContainer">
           <img src="https://github.com/XanderPeeters/Schakelboekje/blob/master/De_Lijn.svg.png?raw=true" alt="De Lijn logo" width="75" height="auto" onclick="reloadPage()">
        </div>
        <div id="editorLoginContainer">
            <button id="editorLoginButton" onclick="openEditorLoginPage()">Editor page</button>
        </div>
    </div>
    <div class="control-box">
        <label for="visible_map">Kaart:</label>
        <input id="visible_map" class="visible" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="visibleGrey">Grijze achtergrond:</label>
        <input id="visibleGrey" type="checkbox"/>
    </div>
    <div class="control-box">
        <label for="metroSwitch">Metro schakelaars</label>
        <input id="metroSwitch" class="switch" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="bovengrondsSwitch">Bovengronds schakelaars:</label>
        <input id="bovengrondsSwitch" class="switch" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="voedingenMetro">Metro Voedingen:</label>
        <input id="voedingenMetro" class="switch" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="voedingenBovengronds">Bovengronds Voedingen:</label>
        <input id="voedingenBovengronds" class="switch" type="checkbox" checked/>
    </div>
    <div class="control-box">
        <label for="searchInput">Zoek op adres, voeding of schakelaar:</label>
        <input id="searchInput" type="text" class="awesomplete" data-list="#addressList" />
        <datalist id="addressList"></datalist>
    </div>
    <div class="control-box">
        <button onclick="searchLayerFeatureOrAddress()">Zoeken</button>
        <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
    </div>
    <div class="control-box">
        <button id="draw_Button" onclick="toggleDrawing()">Teken</button>
    </div>
</div>
<div id="map"></div>
<div id="popup" class="popup" style="display: none;"></div>
<div class="legend">
    <label>Legende:</label>
    <div>
        <i class="fas fa-dot-circle" style="color: red;"></i> <span style="color: red;">Gesloten</span><br>
        <i class="fas fa-dot-circle" style="color: green;"></i> <span style="color: green;">Open</span>
    </div>
</div>
<script>
    let map;
    let draw;

    function openEditorLoginPage() {
        window.location.href = "login.html"; // Redirect to the user page again
    }

    // Load JSON file from server
    async function loadJSONFile() {
        try {
            const response = await fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/sectieschakelaars.json'); // Update the path as needed
            if (!response.ok) {
                throw new Error('Failed to fetch JSON file');
            }
            return await response.json();
        } catch (error) {
            console.error('Error loading JSON file:', error);
            throw error;
        }
    }

    // Function to find the items corresponding to a given V-number
    async function find_switches(main_feeder) {
        try {
            // Load JSON file from server
            const response = await fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/sectieschakelaars.json'); // Update the path as needed
            if (!response.ok) {
                throw new Error('Failed to fetch JSON file');
            }
            const jsonData = await response.json();

            // Ensure jsonData is an array
            if (!Array.isArray(jsonData)) {
                throw new Error('Invalid JSON data format');
            }

            // Find the corresponding items for the given V-number
            const switchesRow = jsonData.find(row => row['V-number'] === main_feeder);

            // Return the items if found
            return switchesRow ? switchesRow['Items'] : 'Not found';
        } catch (error) {
            console.error('Error reading JSON file:', error);
            throw error;
        }
    }



    const center = ol.proj.fromLonLat([4.4024643, 51.2194475]);
    const extentSize = 25000; // Size of the extent in meters (10 km = 10000 meters)
    const extent = ol.extent.buffer(center.concat(center), extentSize);

    const view = new ol.View({
        center: center,
        zoom: 13,
        extent: extent // Set the extent
    });

    let pinClicked = false;
    let drawingModeActive = false;
    let drawnFeaturesSource = new ol.source.Vector(); // Source to hold drawn features
    let drawnFeaturesLayer = new ol.layer.Vector({ // Layer to display drawn features
        source: drawnFeaturesSource,
    });

    map = new ol.Map({
        layers: [
            new ol.layer.Tile({
                source: new ol.source.TileJSON({
                    url: 'https://api.maptiler.com/maps/basic-v2/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
                    tileSize: 512,
                    crossOrigin: 'anonymous',
                })
            })
        ],
        target: 'map',
        view: view // Use the view with the custom extent
    });

    const pointerElement = document.createElement('i');
    pointerElement.className = 'pointer fa-solid fa-location-dot';
    const pointerOverlay = new ol.Overlay({
        element: pointerElement,
        positioning: 'center-center',
        stopEvent: false
    });
    map.addOverlay(pointerOverlay);

    function toggleDrawing() {
        if (drawingModeActive) {
            // Clear previously drawn features if exiting drawing mode
            drawnFeaturesSource.clear();
            map.removeInteraction(draw);
            document.getElementById('draw_Button').style.backgroundColor = '';
        } else {
            // Clear previously drawn features if starting a new drawing
            drawnFeaturesSource.clear();
            document.getElementById('draw_Button').style.backgroundColor = 'green';
            initDrawingInteraction();

        }
        drawingModeActive = !drawingModeActive;
    }

    function initDrawingInteraction() {
        if (!drawnFeaturesSource || !feeder_layer || !map) {
            console.error('Missing required sources or map.');
            return;
        }

        draw = new ol.interaction.Draw({
            source: drawnFeaturesSource,
            type: 'Polygon',
        });
        map.addInteraction(draw);

        draw.on('drawend', async function(event) {
            // Clear previous polygon
            drawnFeaturesSource.clear();


            // Lock the current polygon
            const polygonFeature = event.feature;
            const polygonGeometry = polygonFeature.getGeometry();

            polygonFeature.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'blue',
                    width: 2,
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(0, 0, 255, 0.2)',
                }),
            }));

            // Add the drawn feature to the permanent layer
            drawnFeaturesSource.addFeature(polygonFeature);

            // Perform spatial query against features in Layer 2
            const intersectingFeatures = new Set();
            const polygonExtent = polygonGeometry.getExtent();

            const features = feeder_layer.getSource().getFeatures();
            await Promise.all(features.map(async (feature) => {
                const featureGeometry = feature.getGeometry();
                const featureExtent = featureGeometry.getExtent();
                if (ol.extent.intersects(polygonExtent, featureExtent)) {
                    const layerName = feature.get('LAYER');
                    const main_feeder = layerName;
                    const switches = await find_switches(main_feeder);
                    const edgeFeedersSet = findEdgeFeeders(main_feeder); // Call the function to find edge feeders
                    const edgeFeeders = [...edgeFeedersSet]; // Convert Set to Array for easier handling
                    let layerData = { layerName: layerName, edgeFeeders: edgeFeeders, Switches: switches };
                    let isNewLayer = true;
                    for (let data of intersectingFeatures) {
                        if (data.layerName === layerName) {
                            isNewLayer = false;
                            break;
                        }
                    }
                    if (isNewLayer) {
                        intersectingFeatures.add(layerData);
                    }
                }
            }));

            // Display popup with information about intersecting features
            handlePinClick();
            const popupElement = document.querySelector('.popup');
            if (intersectingFeatures.size > 0) {
                const popupContent = Array.from(intersectingFeatures).map(function(data) {
                    const feederName = data.layerName;
                    const edgeFeeders = data.edgeFeeders;
                    const switches = data.Switches
                    // Populate the tsFeederMap object with main and edge feeder names
                     const tsFeederMap = populateTSFeederMap([feederName, ...edgeFeeders]);

                    // Generate the "Feeders to turn off" section content
                    let feedersToTurnOffContent = '<p>Feeders to turn off:</p>';
                    for (const tsNumber in tsFeederMap) {
                        const feederList = tsFeederMap[tsNumber].join(', ');
                        // Include a message for "N/A" TS numbers
                        const tsNumberDisplay = tsNumber !== 'N/A' ? `TS ${tsNumber}` : 'No corresponding TS-number';
                        feedersToTurnOffContent += `<p>${tsNumberDisplay}: ${feederList}</p>`;
                    }

                    return `<h4 style="margin-top: 0;">Location information:</h4><p>Main feeder: ${feederName}</p><p>Edge feeders: ${edgeFeeders}</p><p>Switches: ${switches}</p> ${feedersToTurnOffContent}`;
                }).join('<hr>'); // Separate feature information with horizontal line
                popupElement.innerHTML = popupContent;
                // Add the export button separately outside of the mapping function
                popupElement.innerHTML += '<button id="exportButton" class="export-button">Export schakelnota</button>';

            } else {
                // If no intersecting features, display a message
                popupElement.style.display = 'none';
            }

            // Clear the drawing interaction (but keep it active)
            draw.finishDrawing();
        });
    }


    // Function to display a popup with location information
    async function displayPopup(coordinates, feature, layer) {
        handlePinClick();
        const popupElement = document.querySelector('.popup');
        const transfcoordinates = ol.proj.transform(coordinates, 'EPSG:3857', 'EPSG:4326');

        if (feature) {
            const closestFeatureName = feature.get('LAYER');
            if (layer === 'feeder_layer') {
                const main_feeder = closestFeatureName;
                const switches = await find_switches(main_feeder);
                const edgeFeedersSet = findEdgeFeeders(main_feeder);
                const edgeFeeders = [...edgeFeedersSet];
                const tsFeederMap = populateTSFeederMap([closestFeatureName, ...edgeFeeders]);

                let feedersToTurnOffContent = '<p>Feeders to turn off:</p>';
                for (const tsNumber in tsFeederMap) {
                    const feederList = tsFeederMap[tsNumber].join(', ');
                    const tsNumberDisplay = tsNumber !== 'N/A' ? `TS ${tsNumber}` : 'No corresponding TS-number';
                    feedersToTurnOffContent += `<p>${tsNumberDisplay}: ${feederList}</p>`;
                }

                const content = `<h4 style="margin-top: 0;">Location information:</h4>
                                <p>Main feeder: ${closestFeatureName}</p>
                                <p>Edge feeders: ${edgeFeeders}</p>
                                <p>Switches: ${switches}</p>
                                ${feedersToTurnOffContent}
                                <button id="exportButton" class="export-button">Export schakelnota</button>`;
                popupElement.innerHTML = content;

            // if we are working in the switches_layer, find the closest feeder and start from there to fill the popup
            } else if (layer === 'switches_layer') {
                // Find the closest main feeder to the input coordinates
                let closestMainFeeder = null;
                let closestDistance = Infinity;

                feeder_layer.getSource().forEachFeature(feederFeature => {
                    const feederName = feederFeature.get('LAYER');
                    const feederCoords = feederFeature.getGeometry().getClosestPoint(coordinates);
                    const distance = ol.sphere.getDistance(transfcoordinates, ol.proj.transform(feederCoords, 'EPSG:3857', 'EPSG:4326'));
                   
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestMainFeeder = feederName;
                    }
                });
                // Display information for the closest main feeder found
                if (closestMainFeeder) {
                    const switches = await find_switches(closestMainFeeder);
                    const edgeFeedersSet = findEdgeFeeders(closestMainFeeder);
                    const edgeFeeders = [...edgeFeedersSet];
                    const tsFeederMap = populateTSFeederMap([closestMainFeeder, ...edgeFeeders]);

                    let feedersToTurnOffContent = '<p>Feeders to turn off:</p>';
                    for (const tsNumber in tsFeederMap) {
                        const feederList = tsFeederMap[tsNumber].join(', ');
                        const tsNumberDisplay = tsNumber !== 'N/A' ? `TS ${tsNumber}` : 'No corresponding TS-number';
                        feedersToTurnOffContent += `<p>${tsNumberDisplay}: ${feederList}</p>`;
                    }

                    const content = `<h4 style="margin-top: 0;">Location information:</h4>
                                    <p>Main feeder: ${closestMainFeeder}</p>
                                    <p>Edge feeders: ${edgeFeeders}</p>
                                    <p>Switches: ${switches}</p>
                                    ${feedersToTurnOffContent}
                                    <button id="exportButton" class="export-button">Export schakelnota</button>`;
                    popupElement.innerHTML = content;
                } else {
                    popupElement.innerHTML = '<p>No main feeder found nearby.</p>';
                }
            }
        } else {
            const lon = transfcoordinates[0];
            const lat = transfcoordinates[1];
            const content = `<p>Latitude: ${lat.toFixed(6)}</p><p>Longitude: ${lon.toFixed(6)}</p>`;
            popupElement.innerHTML = content;
        }

        placePin(coordinates);
    }


    map.on('click', async function(event) {
        if (drawingModeActive) {
            //No functionality yet
        } else {
            handlePinClick();
            const coordinates = event.coordinate;
            const transfcoordinates = ol.proj.transform(coordinates, 'EPSG:3857', 'EPSG:4326');
            let closestFeature = null;
            let closestDistance = Infinity; // Initialize with infinity
            feeder_layer.getSource().forEachFeature(function(feature) {
                const featureCoordinates = feature.getGeometry().getClosestPoint(coordinates);
                const featureCoords = ol.proj.transform(featureCoordinates, 'EPSG:3857', 'EPSG:4326');
                const distance = ol.sphere.getDistance(transfcoordinates, featureCoords);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestFeature = feature;
                }
            });

            // Check if distance exceeds the threshold (for example, 500 meters)
            if (closestDistance <= 500) {
                console.log('Closest Feature:', closestFeature.get('LAYER'));
                const closestFeatureName = closestFeature ? closestFeature.get('LAYER') : null;
                await displayPopup(coordinates, closestFeature, 'feeder_layer');
            } else {
                popupElement.style.display = 'none'; // Hide the popup if distance exceeds threshold
            }

        }
    });


    //function to place pin
    function placePin(pinCoordinates) {
        pointerOverlay.setPosition(pinCoordinates);
    }

    // Function to handle the pin click event
    function handlePinClick() {
        pinClicked = true;
        const popupElement = document.getElementById('popup');
        if (pinClicked) {
            popupElement.style.display = 'block';
        } else {
            popupElement.style.display = 'none';
        }
    }

    //function to find the TS number for a given feeder name
    function findTSNumber(feederName) {
        // Loop through each feature in the GeoJSON data
        for (const feature of Feeders_source.getFeatures()) {
            // Check if the feature's 'LAYER' name matches the given feederName
            if (feature.get('LAYER') === feederName) {
                // Return the TS number of the matched feature
                const tsNumber = feature.get('TS');
                return tsNumber !== null ? tsNumber : 'N/A'; // Return "N/A" if TS number is null
            }
        }
        // Return "N/A" if no matching feeder name is found
        return 'N/A';
    }


    // Create an object to store TS numbers and associated feeder names
    const tsFeederMap = {};

    // Function to populate the tsFeederMap object
    function populateTSFeederMap(feederNames) {
        const tsFeederMap = {}; // Clear tsFeederMap object
        feederNames.forEach(feederName => {
            const tsNumber = findTSNumber(feederName);
            if (tsNumber) {
                if (!tsFeederMap[tsNumber]) {
                    tsFeederMap[tsNumber] = [feederName];
                } else {
                    tsFeederMap[tsNumber].push(feederName);
                }
            }
        });
        return tsFeederMap; // Return the populated tsFeederMap object
    }



    // Add a click event listener to the pin element
    pointerElement.addEventListener('click', function(event) {
        // Prevent the singleclick event on the map from firing
        event.stopPropagation();
        handlePinClick();
    });

    map.on('dblclick', function(event) {
        if (drawingModeActive) {
            // Prevent map zoom on double-click during drawing mode
            event.preventDefault();
        }
    });

    map.getViewport().addEventListener('contextmenu', function(event) {
        if (drawingModeActive) {
            // Finish drawing on right-click
            event.preventDefault();
            draw.finishDrawing();

        } else {
           // Prevent the default context menu from appearing
           event.preventDefault();
           // Hide the pointer
           placePin(undefined);
           const popupElement = document.getElementById('popup');
           popupElement.style.display = 'none';
        }
    });
    map.addLayer(drawnFeaturesLayer);

    // Object to store the colors for each layer
    const layerColors = {};

    // Load GeoJSON data for the first layer
    const Switches_source = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/Switches_Complete2%20(2).geojson',
        format: new ol.format.GeoJSON(),
        crossOrigin: 'anonymous',
    });

    // Style for the switches layer with red/green color and label
    const switches_style = function(feature) {
        const layerName = feature.get('LAYER'); // Get the name of the layer from the 'LAYER' property;
        const plaats = feature.get('PLAATS'); // Get the 'PLAATS' attribute
        const detail = feature.get('DETAIL1');
        const state = feature.get('State');
        let color = 'green'; // Set color to red by default

        // Check if the state is "closed", then change the color to green
        if (state === 'open') {
            color = 'red';
        }

        // Calculate label visibility based on zoom level
        const minZoomLevel = 17; // Adjust the minimum zoom level as needed
        const visible = map.getView().getZoom() >= minZoomLevel;

        // Create style for the feature
        return new ol.style.Style({
            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: color // Use the color
                }),
                stroke: new ol.style.Stroke({
                    color: color, // Use the color
                    width: 2
                })
            }),
            text: new ol.style.Text({
                text: visible ? (map.getView().getZoom() >= 20 ? layerName + (plaats ? ' - ' + plaats : '') + (detail ? ' - ' + detail : '') : layerName) : '', // Show layer name from zoom level 15 and add 'PLAATS' from zoom level 20
                font: 'bold 10px Calibri,sans-serif', // Adjust font size
                offsetY: -12,
                fill: new ol.style.Fill({ color: 'black' }), // Use the same color for the label
                // Custom function to adjust label placement to avoid collisions
                overflow: true, // Allow text to overflow the container if necessary
                placement: 'point', // Place the text at a point on the feature
                padding: [5, 5, 5, 5], // Padding around the text to avoid collision
                textAlign: 'center', // Center-align the text
                textBaseline: 'middle', // Align the text vertically at the center
                stroke: new ol.style.Stroke({ // Stroke style for the text
                    color: '#fff', // White color for the stroke
                    width: 3 // Stroke width
                })
            })
        });
    };

    function findEdgeFeeders(mainFeederName) {
    const edgeFeedersSet = new Set();

    // Find all instances of the main feeder and collect its outer points
    const mainFeederPoints = new Set();
    feeder_layer.getSource().forEachFeature(function(feature) {
        const featureName = feature.get('LAYER');
        if (featureName === mainFeederName) {
            const featureGeometry = feature.getGeometry();
            featureGeometry.getCoordinates().forEach(lineString => {
                const lineStringLength = lineString.length;
                mainFeederPoints.add(lineString[0].toString());
                mainFeederPoints.add(lineString[lineStringLength - 1].toString());
            });
        }
    });

    // Iterate through all features and find intersecting edge feeders
    feeder_layer.getSource().forEachFeature(function(feature) {
        const featureName = feature.get('LAYER');
        if (featureName !== mainFeederName) {
            const featureGeometry = feature.getGeometry();
            featureGeometry.getCoordinates().forEach(lineString => {
                lineString.forEach(point => {
                    if (mainFeederPoints.has(point.toString())) {
                        edgeFeedersSet.add(featureName); // Add to the Set
                    }
                });
            });
        }
    });

    return edgeFeedersSet;
}


    // Load GeoJSON data for the grey map layer
    const greyMapSource = new ol.source.TileJSON({
        url: 'https://api.maptiler.com/maps/basic-v2-light/tiles.json?key=VTEyqAvEoi2G2xhpCGmi',
        tileSize: 512,
        crossOrigin: 'anonymous',
    });

    // Create the grey map layer
    const greyMapLayer = new ol.layer.Tile({
        source: greyMapSource,
        visible: false // Initially set to invisible
    });

    // Add the grey map layer to the map
    map.addLayer(greyMapLayer);


    // Create the first vector layer
    const switches_layer = new ol.layer.Vector({
        source: Switches_source,
        style: switches_style
    });

    // Add the first vector layer to the mapp
    map.addLayer(switches_layer);

    // Load GeoJSON data for the second layer
    const Feeders_source = new ol.source.Vector({
        url: 'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/Voedingen-stadsplan.geojson',
        format: new ol.format.GeoJSON(),
        crossOrigin: 'anonymous',
    });


    // Create the second vector layer without style
    const feeder_layer = new ol.layer.Vector({
        source: Feeders_source,
        zIndex: 1
    });

    // Add the second vector layer to the map
    map.addLayer(feeder_layer);


    // Define a mapping of feeder names to image URLs
    const feederImageMap = {
        'V037': 'https://github.com/XanderPeeters/Schakelboekje/blob/master/Afbeeldingen%20details/Detail%20stelplaats%20V037.png?raw=true',
        'V314': 'https://github.com/XanderPeeters/Schakelboekje/blob/master/Afbeeldingen%20details/Detail%20V361V314.png?raw=true',
        'V361' : 'https://github.com/XanderPeeters/Schakelboekje/blob/master/Afbeeldingen%20details/Detail%20V361.png?raw=true',
        'V353' : 'https://github.com/XanderPeeters/Schakelboekje/blob/master/Afbeeldingen%20details/Detail%20V353.png?raw=true',
        // Add more mappings as needed
    };

    // Fetch JSON data from the server
    fetch('https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/Kleuren.json')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch JSON file');
            }
            return response.json();
        })
        .then(data => {
            // Define a map to store colors for feeders
            const feederColors = new Map(data.map(entry => [entry.LAYER, entry.COLOR]));

            // Modified style function to use assigned colors for feeders and prevent text overlap
            const feeder_styling = function(feature, resolution) {
                const layerName = feature.get('LAYER'); // Get the name of the feeder from the 'LAYER' property

                // Get color for the current feeder from the map
                const color = feederColors.get(layerName);

                // If color is found, create style for the feature
                if (color) {
                    // Function to handle click event on layer name
                    const handleClick = function() {
                        const imageUrl = feederImageMap[layerName];
                        if (imageUrl) {
                            window.open(imageUrl, '_blank');
                        } else {
                            console.error('Image URL not found for feeder:', layerName);
                        }
                    };

                    // Calculate font size based on zoom level
                    const minFontSize = 10; // Adjust the minimum font size as needed
                    const maxFontSize = 14; // Adjust the maximum font size as needed
                    const zoom = map.getView().getZoom();
                    const fontSize = Math.max(minFontSize, maxFontSize - (zoom - 10)); // Adjust the base zoom level as needed (10 in this example)

                    // Style for the feature
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: color,
                            width: 3
                        }),
                        text: new ol.style.Text({
                            text: map.getView().getZoom() >= 15 ? layerName : '',  // Always show the label
                            font: `bold ${fontSize}px Calibri,sans-serif`, // Adjust font size dynamically based on zoom level
                            offsetY: -12,
                            fill: new ol.style.Fill({ color: 'black' }),
                            // Event listener for click on layer name
                            onClick: handleClick,
                            overflow: true, // Allow text to overflow the container if necessary
                            placement: 'point', // Place the text at a point on the feature
                            maxAngle: Math.PI / 6, // Limit the rotation of the text
                            textAlign: 'center', // Center-align the text
                            textBaseline: 'middle', // Align the text vertically at the center
                            stroke: new ol.style.Stroke({ // Stroke style for the text
                                color: '#fff', // White color for the stroke
                                width: 3 // Stroke width
                            })
                        })
                    });
                } else {
                    // If color is not found, handle as needed
                    console.error('Color not found for layer:', layerName);
                    // You can choose to assign a default color or handle the situation differently
                    return null;
                }
            };

            // Set style function for the vector layer
            feeder_layer.setStyle(feeder_styling);
        })
        .catch(error => {
            console.error('Error reading JSON file:', error);
            // Handle error here
        });

    // Troubleshooting: Add an event listener to check for errors
    feeder_layer.getSource().on('change', function(evt) {
        if (feeder_layer.getSource().getState() === 'ready') {
            console.log('Data loaded successfully.');
        } else if (feeder_layer.getSource().getState() === 'error') {
            console.error('Error loading data:', feeder_layer.getSource().getLoadingError());
        }
    });

    // Function to handle layer visibility
    function handleLayerVisibility(layer, checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        checkbox.addEventListener('change', function() {
            layer.setVisible(this.checked);
        });
    }


        // Create a new select interaction
    const selectInteraction = new ol.interaction.Select({
        condition: ol.events.condition.click // Trigger selection on click
    });

    // Add the select interaction to the map
    map.addInteraction(selectInteraction);

    // Event listener for feature selection
    selectInteraction.on('select', function(event) {
        const selectedFeatures = event.target.getFeatures();
        if (selectedFeatures.getLength() > 0) {
            const selectedFeature = selectedFeatures.item(0);
            const layerName = selectedFeature.get('LAYER');
            const imageUrl = feederImageMap[layerName];
            if (imageUrl) {
                window.open(imageUrl, '_blank');
            } else {
                console.error('Image URL not found for feeder:', layerName);
            }
        }
    });

    const popupElement = document.getElementById('popup');
    popupElement.addEventListener('click', function(event) {
        if (event.target.id === 'exportButton') {
            const files = [
                'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voorbeelden%20schakelnota/Voeding%20165.xlsm',
                'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voorbeelden%20schakelnota/Voorbeeld%20voeding%20101.xlsm',
                'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voorbeelden%20schakelnota/voeding%20152.xlsm',
                'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voorbeelden%20schakelnota/voeding%20332.xlsm',
                'https://raw.githubusercontent.com/XanderPeeters/Schakelboekje/master/voorbeelden%20schakelnota/voeding%2081.xlsm'
            ];

            const randomIndex = Math.floor(Math.random() * files.length);
            const randomFileURL = files[randomIndex];

            // Fetch the file content
            fetch(randomFileURL)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to fetch file');
                    }
                    return response.blob();
                })
                .then(blob => {
                    // Create a temporary anchor element to download the file
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = `Schakelnota_${randomIndex}.xlsm`; // Generate a dynamic filename
                    downloadLink.click();
                })
                .catch(error => {
                    console.error('Error fetching file:', error);
                    // Handle error here
                });
            const content = popupElement.innerHTML;
            //exportToExcel(content);
            // Get the drawn polygon from the drawn features layer if it exists
            //const drawnPolygon = getDrawnPolygon();
            //if (drawnPolygon) {
            //  exportMapImagePolygon(drawnPolygon); // Pass the drawn polygon
            // } else {
                // If no drawn polygon exists, export the current map view as an image
            // exportMapImage();
            // }
        }
    });


    // Function to get the drawn polygon from the drawn features layer
function getDrawnPolygon() {
    const drawnFeatures = drawnFeaturesLayer.getSource().getFeatures();
    if (drawnFeatures.length > 0) {
        return drawnFeatures[0].getGeometry(); // Return the geometry of the first feature
    } else {
        return null; // Return null if no features are found
    }
}

function exportMapImagePolygon(drawnPolygon) {
    // Find all main feeder features
    const mainFeederFeatures = [];
    const mainFeederSections = document.querySelectorAll('.popup p');

    // Clear the drawn features layer
    drawnFeaturesLayer.getSource().clear();

    mainFeederSections.forEach(section => {
        if (section.textContent.includes('Main feeder')) {
            const mainFeederNames = section.textContent
                .split(': ')[1]
                .split(', ')
                .map(name => name.trim());

            // Collect all main feeder features without duplicates
            mainFeederNames.forEach(mainFeederName => {
                feeder_layer.getSource().forEachFeature(feature => {
                    const layerName = feature.get('LAYER');
                    if (layerName === mainFeederName) {
                        mainFeederFeatures.push(feature);
                    }
                });
            });
        }
    });

    // Calculate the extent bounding box around all main feeder(s)
    const mainFeederExtent = ol.extent.createEmpty();
    mainFeederFeatures.forEach(feature => {
        ol.extent.extend(mainFeederExtent, feature.getGeometry().getExtent());
    });

    // Zoom the map to the extent of the main feeder features
    map.getView().fit(mainFeederExtent, { duration: 1000 });

    // Delay to ensure the map has rendered at the desired zoom level
    setTimeout(() => {
        // Get the canvas element within the map viewport
        const mapCanvas = document.querySelector('.ol-viewport canvas');

        // Create an image element
        const img = new Image();

        // Set the cross-origin attribute to "anonymous"
        img.crossOrigin = "anonymous";

        // Set the image source to the data URL of the canvas
        img.src = mapCanvas.toDataURL('image/png');

        // Create a temporary anchor element to download the image
        const downloadLink = document.createElement('a');

        // Set the href attribute to the image source
        downloadLink.href = img.src;

        // Set the download attribute to specify the file name
        downloadLink.download = 'map_image.png';

        // Click the anchor element to trigger the download
        downloadLink.click();
    }, 1500); // Adjust this delay as needed to ensure the map has rendered at the desired zoom level
}





// Function to calculate the bounding box of the main feeder features and zoom to it
function zoomToMainFeederExtent(mainFeederFeatures) {
    const mainFeederExtent = ol.extent.createEmpty();
    mainFeederFeatures.forEach(feature => {
        ol.extent.extend(mainFeederExtent, feature.getGeometry().getExtent());
    });
    // Zoom the map to the calculated extent
    map.getView().fit(mainFeederExtent, { duration: 1000 });
}


    function exportMapImage() {
    // Get the current map view
    const mapView = map.getView();

    // Retrieve the content of the popup
    const popupContent = document.querySelector('.popup').innerHTML;

    // Create a temporary element to parse the HTML content of the popup
    const tempElement = document.createElement('div');
    tempElement.innerHTML = popupContent;

    // Retrieve the main feeder(s) information from the popup content
    const mainFeederInfo = Array.from(tempElement.querySelectorAll('p')).find(p => p.textContent.includes('Main feeder'));
    let mainFeederExtent = null;

    if (mainFeederInfo) {
        // Extract the main feeder name(s)
        const mainFeederNames = mainFeederInfo.textContent.split(': ')[1].split(', ');

        // Find features corresponding to all instances of the main feeder(s)
        const mainFeederFeatures = [];
        mainFeederNames.forEach(name => {
            feeder_layer.getSource().forEachFeature(feature => {
                if (feature.get('LAYER') === name) {
                    mainFeederFeatures.push(feature);
                }
            });
        });

        // Calculate the extent bounding box around all main feeder(s)
        mainFeederExtent = ol.extent.createEmpty();
        mainFeederFeatures.forEach(feature => {
            ol.extent.extend(mainFeederExtent, feature.getGeometry().getExtent());
        });

        // Fit the map view to the calculated extent
        mapView.fit(mainFeederExtent, { duration: 1000 });
    }

    // Delay to ensure the map has rendered at the new extent
    setTimeout(() => {
        // Get the canvas element within the map viewport
        const mapCanvas = document.querySelector('.ol-viewport canvas');

        // Create a temporary anchor element to download the image
        const downloadLink = document.createElement('a');
        downloadLink.href = mapCanvas.toDataURL('image/png');
        downloadLink.download = 'map_image.png';
        downloadLink.click();

        // Restore the original map view if main feeder extent was calculated
        if (mainFeederExtent) {
            mapView.fit(view.getExtent(), { duration: 1000 });
        }
    }, 1500); // Adjust this delay as needed to ensure the map has rendered at the new extent
}
   

    function exportToExcel() {
    // Retrieve the content of the popup
    const popupContent = document.querySelector('.popup').innerText;

    // Split the content by sections
    const sections = popupContent.split('Location information:');

    // Filter out empty sections
    const filteredSections = sections.filter(section => section.trim() !== '');

    // Process each section to extract data
    const data = [];
    filteredSections.forEach(section => {
        // Check if section is empty
        if (section.trim() !== '') {
            const lines = section.trim().split('\n');
            const rowData = [];
            lines.forEach(line => {
                // Check if line contains label and value
                if (line.includes(':')) {
                    const [label, value] = line.split(':');
                    rowData.push(label.trim(), value.trim());
                }
            });
            // Push rowData to data array if it contains data
            if (rowData.length > 0) {
                data.push(rowData);
            }
        }
    });

    // Create a new workbook
    const workbook = XLSX.utils.book_new();

    // Convert the data to worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(data);

    // Add the worksheet to the workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Feeder Data');

    // Convert the workbook to a Blob
    const blob = new Blob([s2ab(XLSX.write(workbook, { type: 'binary' }))], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

    // Save the Blob as a file using FileSaver.js
    saveAs(blob, 'feeder_data.xlsx');
}

    // Utility function to convert array buffer to binary string
    function s2ab(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xff;
        return buf;
    }

    //function to zoom to a specific location
    function zoomToLocationOrLayer(feature) {
        const extent = feature.getGeometry().getExtent();
        map.getView().fit(extent, {duration: 1000, maxZoom: 18});

        // Calculate the center of the extent
        const centerX = (extent[0] + extent[2]) / 2;
        const centerY = (extent[1] + extent[3]) / 2;
        const centerCoordinates = [centerX, centerY];
        return centerCoordinates;
    }
       

    // Function to zoom to a specific location or layer
    async function searchLayerFeatureOrAddress() {
        const searchText = document.getElementById('searchInput').value;
        if (!searchText) {
            document.getElementById('errorMessage').textContent = 'Voeding, Schakelaar of adres niet gevonden';
            return;
        }
       
        const layers = [
            { layer: feeder_layer, name: 'feeder_layer' },
            { layer: switches_layer, name: 'switches_layer' }
        ];

        let found = false;
        let wronginput = false;


        for (const { layer, name } of layers) {
            layer.getSource().forEachFeature(feature => {
                if (feature.get('LAYER') === searchText) {
                    zoomToLocationOrLayer(feature);
                    const centerCoordinates = zoomToLocationOrLayer(feature);
                    const currentLayer = name;
                    placePin(centerCoordinates);
                    displayPopup(centerCoordinates, feature, currentLayer);
                    found = true;
                    return;
                } else {
                    wronginput = true;
                }
            });
        };

        if (!found) {
            geocodeAddress(searchText)
        }
        if (!found && !wronginput) {
            geocodeAddress(searchText)
            //remove popup in this condition
            const popupElement = document.getElementById('popup');
            popupElement.style.display = 'none';  
            popupElement.style.display = 'none';
        } else if (!found && wronginput) {
            document.getElementById('errorMessage').textContent = ''; // Clear error message
            const popupElement = document.getElementById('popup');    
        } else {
            document.getElementById('errorMessage').textContent = ''; // Clear error message
            const popupElement = document.getElementById('popup');
        }
    }

    // Function to geocode an address and zoom to its location
    function geocodeAddress(address) {
        const fullAddress = address;
        const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=1&q=' + encodeURIComponent(fullAddress);
        fetch(url)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                if (data && data.length > 0) {
                    const location = data[0];
                    const coordinates = [parseFloat(location.lon), parseFloat(location.lat)];
                    map.getView().animate({ center: ol.proj.fromLonLat(coordinates), zoom: 18, duration: 1000 });
                } else {
                    alert('Voeding, schakelaar of adres niet gevonden!');
                }
            })
            .catch(function(error) {
                console.error('Error geocoding address:', error);
            });
    }

    // Function to fetch address suggestions and populate the datalist
    async function fetchAddressSuggestions(input) {
        const antwerpBounds = '4.2355,51.1591,4.4728,51.2463'; // Antwerp bounding box
        const url = `https://nominatim.openstreetmap.org/search?format=json&viewbox=${antwerpBounds}&bounded=1&limit=5&q=${encodeURIComponent(input)}`;
        try {
            const response = await fetch(url);
            const data = await response.json();
            console.log(data); // Log the response
            const suggestions = data.map(item => item.display_name);
            return suggestions;
        } catch (error) {
            console.error('Error fetching address suggestions:', error);
            return [];
        }
    }


    document.addEventListener('DOMContentLoaded', function() {
            // Your JavaScript code here
            const input = document.getElementById('searchInput');
            const list = document.getElementById('addressList');
            const awesomplete = new Awesomplete(input, { list });

            input.addEventListener('input', async function() {
                const suggestions = await fetchAddressSuggestions(input.value);
                awesomplete.list = suggestions;
            });
        });


    function reloadPage() {
        location.reload();
    }

    document.addEventListener('DOMContentLoaded', function () {
        const metroSwitch = document.getElementById('metroSwitch');
        const bovengrondsSwitch = document.getElementById('bovengrondsSwitch');

        metroSwitch.addEventListener('change', function () {
            updateSwitchesVisibility();
        });

        bovengrondsSwitch.addEventListener('change', function () {
            updateSwitchesVisibility();
        });

        function updateSwitchesVisibility() {
            const metroVisible = metroSwitch.checked;
            const bovengrondsVisible = bovengrondsSwitch.checked;

            // Loop through all features and update visibility based on checkbox state
            Switches_source.getFeatures().forEach(function (feature) {
                const metro = feature.get('metro?');
                if ((metro === 'metro' && metroVisible) || (metro === 'boven' && bovengrondsVisible)) {
                    feature.setStyle(null); // Show the feature
                } else {
                    feature.setStyle(new ol.style.Style({ // Hide the feature
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'rgba(255, 255, 255, 0)'
                        })
                    }));
                }
            });
        }
    });

    document.addEventListener('DOMContentLoaded', function () {
        const voedingenMetroSwitch = document.getElementById('voedingenMetro');
        const voedingenBovengrondsSwitch = document.getElementById('voedingenBovengronds');

        voedingenMetroSwitch.addEventListener('change', function () {
            updateVoedingenVisibility();
        });

        voedingenBovengrondsSwitch.addEventListener('change', function () {
            updateVoedingenVisibility();
        });

        function updateVoedingenVisibility() {
            const voedingenMetroVisible = voedingenMetroSwitch.checked;
            const voedingenBovengrondsVisible = voedingenBovengrondsSwitch.checked;

            // Assuming you have a function Feeders_source.getFeatures() similar to the one used before
            Feeders_source.getFeatures().forEach(function (feature) {
                const metro = feature.get('metro?');
                if ((metro === 'metro' && voedingenMetroVisible) || (metro === 'boven' && voedingenBovengrondsVisible)) {
                    feature.setStyle(null); // Show the feature
                } else {
                    feature.setStyle(new ol.style.Style({ // Hide the feature
                        fill: new ol.style.Fill({
                            color: 'rgba(255, 255, 255, 0)'
                        }),
                        stroke: new ol.style.Stroke({
                            color: 'rgba(255, 255, 255, 0)'
                        })
                    }));
                }
            });
        }
    });

    // Handle visibility for OSM layer
    handleLayerVisibility(map.getLayers().item(0), 'visible_map');

    // Handle visibility for greylayer
    handleLayerVisibility(greyMapLayer, 'visibleGrey');
   
</script>
</body>
</html>
